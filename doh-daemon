#!/bin/bash

# doh-daemon - Auto-commit daemon for monitored directories
# Reads config from ~/.doh/config.json and monitors all registered directories
# Usage: doh-daemon [--once] [--verbose] [--config-check]

DOH_CONFIG_DIR="$HOME/.doh"
DOH_CONFIG_FILE="$DOH_CONFIG_DIR/config.json"
DOH_LOG_DIR="$DOH_CONFIG_DIR/logs"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Global variables
VERBOSE=false
RUN_ONCE=false
CHECK_INTERVAL=600  # 10 minutes default

print_usage() {
    echo "doh-daemon - Auto-commit monitoring daemon"
    echo ""
    echo "Usage: doh-daemon [options]"
    echo ""
    echo "Options:"
    echo "  --once             Run once and exit (good for cron)"
    echo "  --verbose, -v      Verbose output"
    echo "  --config-check     Check configuration and exit"
    echo "  --interval SECS    Check interval in seconds (default: 600)"
    echo "  --help, -h         Show this help"
    echo ""
    echo "Examples:"
    echo "  doh-daemon                    # Run continuously"
    echo "  doh-daemon --once            # Run once (for cron)"
    echo "  doh-daemon --verbose         # Run with detailed output"
}

# Logging function
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local log_file="$DOH_LOG_DIR/daemon_$(date +%Y%m%d).log"
    
    # Ensure log directory exists
    mkdir -p "$DOH_LOG_DIR"
    
    # Color output for terminal
    case "$level" in
        "INFO")  echo -e "${BLUE}[$timestamp] INFO: $message${NC}" ;;
        "WARN")  echo -e "${YELLOW}[$timestamp] WARN: $message${NC}" ;;
        "ERROR") echo -e "${RED}[$timestamp] ERROR: $message${NC}" ;;
        "SUCCESS") echo -e "${GREEN}[$timestamp] SUCCESS: $message${NC}" ;;
        *) echo "[$timestamp] $level: $message" ;;
    esac
    
    # Always log to file without colors
    echo "[$timestamp] $level: $message" >> "$log_file"
}

# Clean old logs
cleanup_logs() {
    local retention_days=$(get_global_setting "log_retention_days" "30")
    
    if [[ -d "$DOH_LOG_DIR" ]]; then
        find "$DOH_LOG_DIR" -name "daemon_*.log" -mtime +$retention_days -delete 2>/dev/null
        find "$DOH_LOG_DIR" -name "auto_commit_*.log" -mtime +$retention_days -delete 2>/dev/null
    fi
}

# Get global setting from config
get_global_setting() {
    local key="$1"
    local default="$2"
    
    if [[ -f "$DOH_CONFIG_FILE" ]]; then
        local value=$(grep -o "\"$key\": *[^,}]*" "$DOH_CONFIG_FILE" | sed "s/\"$key\": *\([^,}]*\)/\1/" | tr -d '"')
        echo "${value:-$default}"
    else
        echo "$default"
    fi
}

# Get directory setting from config
get_directory_setting() {
    local dir_path="$1"
    local key="$2"
    local default="$3"
    
    if [[ -f "$DOH_CONFIG_FILE" ]]; then
        local escaped_path=$(printf '%s' "$dir_path" | sed 's/[[\.*^$()+?{|]/\\&/g')
        local value=$(grep -o "\"$escaped_path\": *{[^}]*\"$key\": *[^,}]*" "$DOH_CONFIG_FILE" | \
                     sed -n "s/.*\"$key\": *\([^,}]*\).*/\1/p" | tr -d '"')
        echo "${value:-$default}"
    else
        echo "$default"
    fi
}

# Update last checked timestamp for a directory
update_last_checked() {
    local dir_path="$1"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local temp_file=$(mktemp)
    
    if [[ -f "$DOH_CONFIG_FILE" ]]; then
        sed "s|\"$dir_path\": *{\\([^}]*\\)\"last_checked\": *\"[^\"]*\"|\"$dir_path\": {\\1\"last_checked\": \"$timestamp\"|" \
            "$DOH_CONFIG_FILE" > "$temp_file"
        mv "$temp_file" "$DOH_CONFIG_FILE"
    fi
}

# Get git stats for a directory (same as doh script)
get_git_stats() {
    local dir="$1"
    
    if [[ ! -d "$dir" ]]; then
        echo "dir_not_found"
        return 1
    fi
    
    if ! git -C "$dir" rev-parse --git-dir >/dev/null 2>&1; then
        echo "not_git"
        return 1
    fi
    
    # Check for changes
    if git -C "$dir" diff --quiet HEAD 2>/dev/null; then
        echo "0:0:0:0:0"
        return 0
    fi
    
    # Get detailed stats
    local stats=$(git -C "$dir" diff --numstat HEAD 2>/dev/null)
    local added=0 deleted=0 files_changed=0
    
    while IFS=$'\t' read -r add del file; do
        if [[ -n "$add" && "$add" != "-" ]]; then
            added=$((added + add))
        fi
        if [[ -n "$del" && "$del" != "-" ]]; then
            deleted=$((deleted + del))
        fi
        if [[ -n "$file" ]]; then
            files_changed=$((files_changed + 1))
        fi
    done <<< "$stats"
    
    # Get untracked files
    local untracked=$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null | wc -l)
    
    local total_changes=$((added + deleted))
    echo "$total_changes:$added:$deleted:$files_changed:$untracked"
}

# Perform auto-commit for a directory
perform_auto_commit() {
    local dir_path="$1"
    local total_changes="$2"
    local added="$3"
    local deleted="$4"
    local files_changed="$5"
    local untracked="$6"
    local threshold="$7"
    
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    local commit_msg="Auto-commit: Snapshot at $timestamp

Changes detected:
- Lines added: $added
- Lines deleted: $deleted
- Total changes: $total_changes
- Files modified: $files_changed
- Untracked files: $untracked

Threshold exceeded ($total_changes > $threshold lines)"
    
    # Stage all changes
    if git -C "$dir_path" add . 2>/dev/null; then
        # Commit changes
        if git -C "$dir_path" commit -m "$commit_msg" 2>/dev/null; then
            log_message "SUCCESS" "Auto-commit successful in $dir_path: +$added/-$deleted lines across $files_changed files"
            return 0
        else
            log_message "ERROR" "Failed to commit changes in $dir_path"
            return 1
        fi
    else
        log_message "ERROR" "Failed to stage changes in $dir_path"
        return 1
    fi
}

# Process a single directory
process_directory() {
    local dir_path="$1"
    
    # Get directory settings
    local threshold=$(get_directory_setting "$dir_path" "threshold" "50")
    
    # Get git stats
    local stats=$(get_git_stats "$dir_path")
    
    case "$stats" in
        "dir_not_found")
            log_message "WARN" "Directory not found: $dir_path (will be removed from config on next cleanup)"
            return 1
            ;;
        "not_git")
            log_message "WARN" "Not a git repository: $dir_path"
            return 1
            ;;
        *)
            IFS=':' read -r total added deleted files untracked <<< "$stats"
            
            if [[ "$total" -gt 0 ]]; then
                if [[ "$total" -ge "$threshold" ]]; then
                    log_message "INFO" "Threshold exceeded in $dir_path: $total changes (threshold: $threshold)"
                    perform_auto_commit "$dir_path" "$total" "$added" "$deleted" "$files" "$untracked" "$threshold"
                else
                    if [[ "$VERBOSE" == true ]]; then
                        log_message "INFO" "Changes detected in $dir_path: $total lines (+$added/-$deleted) in $files files, $untracked untracked (below threshold $threshold)"
                    fi
                fi
            else
                if [[ "$VERBOSE" == true ]]; then
                    log_message "INFO" "No changes in $dir_path"
                fi
            fi
            
            # Update last checked timestamp
            update_last_checked "$dir_path"
            return 0
            ;;
    esac
}

# Get all monitored directories from config
get_monitored_directories() {
    if [[ ! -f "$DOH_CONFIG_FILE" ]]; then
        return 1
    fi
    
    # Extract directory paths from JSON directories section only
    sed -n '/\"directories\": *{/,/}/p' "$DOH_CONFIG_FILE" | grep -o '"[^"]*": {[^}]*}' | sed 's/"\([^"]*\)": {.*/\1/'
}

# Check configuration validity
check_config() {
    if [[ ! -f "$DOH_CONFIG_FILE" ]]; then
        log_message "ERROR" "Configuration file not found: $DOH_CONFIG_FILE"
        log_message "INFO" "Run 'doh' in a git repository to initialize"
        return 1
    fi
    
    # Basic JSON validity check
    if ! python3 -c "import json; json.load(open('$DOH_CONFIG_FILE'))" 2>/dev/null; then
        log_message "ERROR" "Invalid JSON in configuration file"
        return 1
    fi
    
    local dir_count=0
    local valid_dirs=0
    
    while IFS= read -r dir_path; do
        [[ -z "$dir_path" ]] && continue
        dir_count=$((dir_count + 1))
        
        if [[ -d "$dir_path" ]]; then
            if git -C "$dir_path" rev-parse --git-dir >/dev/null 2>&1; then
                valid_dirs=$((valid_dirs + 1))
                local threshold=$(get_directory_setting "$dir_path" "threshold" "50")
                echo "  ✓ $dir_path (threshold: $threshold)"
            else
                echo "  ⚠ $dir_path (not a git repository)"
            fi
        else
            echo "  ✗ $dir_path (directory not found)"
        fi
    done < <(get_monitored_directories)
    
    echo ""
    echo "Summary: $valid_dirs/$dir_count directories are valid"
    
    if [[ "$valid_dirs" -eq 0 ]]; then
        log_message "WARN" "No valid directories to monitor"
        return 1
    fi
    
    return 0
}

# Main monitoring loop
monitor_directories() {
    local cycle_count=0
    
    log_message "INFO" "Starting doh-daemon monitoring"
    log_message "INFO" "Check interval: $CHECK_INTERVAL seconds"
    log_message "INFO" "Run mode: $(if [[ "$RUN_ONCE" == true ]]; then echo "single run"; else echo "continuous"; fi)"
    
    while true; do
        cycle_count=$((cycle_count + 1))
        
        if [[ "$VERBOSE" == true ]]; then
            log_message "INFO" "Starting monitoring cycle #$cycle_count"
        fi
        
        # Clean old logs periodically
        if [[ $((cycle_count % 10)) -eq 1 ]]; then
            cleanup_logs
        fi
        
        # Get and process all directories
        local processed=0
        local successful=0
        
        while IFS= read -r dir_path; do
            [[ -z "$dir_path" ]] && continue
            processed=$((processed + 1))
            
            if process_directory "$dir_path"; then
                successful=$((successful + 1))
            fi
        done < <(get_monitored_directories)
        
        if [[ "$processed" -eq 0 ]]; then
            log_message "WARN" "No directories to monitor. Run 'doh' to add directories."
        else
            if [[ "$VERBOSE" == true ]]; then
                log_message "INFO" "Monitoring cycle #$cycle_count complete: $successful/$processed directories processed successfully"
            fi
        fi
        
        # Exit if running once
        if [[ "$RUN_ONCE" == true ]]; then
            log_message "INFO" "Single run complete"
            break
        fi
        
        # Wait for next cycle
        sleep "$CHECK_INTERVAL"
    done
}

# Signal handlers for graceful shutdown
cleanup_on_exit() {
    log_message "INFO" "Doh-daemon stopped"
    exit 0
}

# Main execution
main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --once)
                RUN_ONCE=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --config-check)
                echo "Checking configuration..."
                check_config
                exit $?
                ;;
            --interval)
                CHECK_INTERVAL="$2"
                shift 2
                ;;
            -h|--help)
                print_usage
                exit 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                print_usage
                exit 1
                ;;
        esac
    done
    
    # Validate check interval
    if ! [[ "$CHECK_INTERVAL" =~ ^[0-9]+$ ]] || [[ "$CHECK_INTERVAL" -lt 1 ]]; then
        log_message "ERROR" "Invalid check interval: $CHECK_INTERVAL"
        exit 1
    fi
    
    # Set up signal handling for graceful shutdown
    trap cleanup_on_exit INT TERM
    
    # Create necessary directories
    mkdir -p "$DOH_CONFIG_DIR" "$DOH_LOG_DIR"
    
    # Check configuration
    if ! check_config >/dev/null 2>&1; then
        log_message "ERROR" "Configuration check failed"
        exit 1
    fi
    
    # Start monitoring
    monitor_directories
}

main "$@"
